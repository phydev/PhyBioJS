<!DOCTYPE html>
<html>
<head><script src='https://cdn.plot.ly/plotly-latest.min.js'></script>
<script src="PhyBioJS/phybio.js"></script>
</head>
<body>

<h1>PhyBioJS</h1>
<p>This is a JavaScript implementation of the phase-field model presented in Ref. [1]. </p>
<input type="number" placeholder="Steps" id="tsteps" value="10000">
<input type="number" placeholder="Lx" id="Lx" value="50">
<input type="number" placeholder="Ly" id="Ly" value="50">
<button onclick="runSim(parseInt(document.getElementById('tsteps').value),
                        parseInt(document.getElementById('Lx').value),
                        parseInt(document.getElementById('Ly').value))">Run</button>

<div id='plotDiv' width="200" height="200"><!-- Plotly chart will be drawn inside this DIV --></div>


<script>

    function runSim(tsteps, Lx, Ly){
        // TODO: move this script to another file

        let phi = anArray.Random(Lx, Ly);
        const dt = 0.001;
        const outPeriod = 1000;
        var layout = {

            autosize: false,
            width: 400,
            height: 400,
            margin: {
                l: 50,
                r: 50,
                b: 100,
                t: 100,
                pad: 4
            }};

        var data = [{
            z: phi,
            type: 'heatmap',
            colorscale: 'Electric',
            zsmooth: 'best'
        }];
        Plotly.newPlot('plotDiv', data, layout);

        integrate(phi, tsteps, outPeriod, dt, Lx, Ly, layout);

    }

    function integrate(phi, tsteps, outPeriod, dt, Lx, Ly, layout){
        var nsteps = 0;
        var niter = outPeriod;

        function allen_cahn(){

            let phi_o = anArray.Zeros(Lx, Ly);
            var cnt = niter;

            while (cnt-- && nsteps<=tsteps ) {
                //for (var nstep = 0; nstep <= tsteps; nstep++) {
                phi_o = phi.slice();

                for (var i = 0; i < Lx; i++) {
                    for (var j = 0; j < Ly; j++) {
                        phi[i][j] = phi_o[i][j] + dt * (laplacian(phi_o, i, j, Lx, Ly) + phi_o[i][j] * (1.0 - phi_o[i][j]) * (phi_o[i][j] - 0.5));
                    }
                }
                nsteps++;
            }
            if (nsteps <= tsteps) {
                    console.log(nsteps);
                    Plotly.animate('plotDiv',{
                        data:{z: phi},
                        type:'heatmap', colorscale: 'Electric', zsmooth: 'best'}, layout);
                    setTimeout(allen_cahn, 1);
                }
        }

        allen_cahn();
    }


    function laplacian(fn, x1, x2, Lx, Ly) {
        // compute the laplacian of fn at the point (x1, x2)
        var yh = 0.0;
        var yl = 0.0;
        let s = [];
        var y = fn[x1][x2];
        var laplacian_value = 0.0;
        s = [x1, x2];

        for (var k = 0; k <= 1; k++) {
            s[k] += 1;
            yh = fn[b(s[0], Lx)][b(s[1], Ly)];
            s[k] -= 2;
            yl = fn[b(s[0], Lx)][b(s[1], Ly)];
            s[k] +=1;
            laplacian_value += (yh + yl - 2.0*y);
        }

        return laplacian_value;
    }

    function b(x, L){
        // check boundary conditions
        // TODO: implement the other conditions
        if (x<0){
            x = L+x;
        }
        else if(x>=L){
            x = x-L;
        }
        return x;
    }
</script>

</body>
</html>